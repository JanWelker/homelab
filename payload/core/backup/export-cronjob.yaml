---
# ConfigMap with backup script
apiVersion: v1
kind: ConfigMap
metadata:
  name: backup-script
  namespace: backup
data:
  backup.sh: |
    #!/bin/bash
    set -euo pipefail

    # Configuration
    BACKUP_ROOT="/backup"
    RETENTION_DAYS="${RETENTION_DAYS:-90}"
    DATE=$(date +%Y-%m-%d_%H-%M-%S)

    echo "=== Backup Export Started at $(date) ==="

    # Namespaces to backup (all namespaces if not specified)
    if [ -z "${BACKUP_NAMESPACES:-}" ]; then
      NAMESPACES=$(kubectl get namespaces -o jsonpath='{.items[*].metadata.name}')
    else
      NAMESPACES="${BACKUP_NAMESPACES}"
    fi

    for NS in $NAMESPACES; do
      echo "Processing namespace: $NS"
      BACKUP_DIR="${BACKUP_ROOT}/${NS}/${DATE}"
      mkdir -p "$BACKUP_DIR"
      
      # Get all PVCs in namespace
      PVCS=$(kubectl get pvc -n "$NS" -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")
      
      for PVC in $PVCS; do
        SC=$(kubectl get pvc "$PVC" -n "$NS" -o jsonpath='{.spec.storageClassName}')
        TARGET="${TARGET_STORAGE_CLASS:-rook-ceph-block}"
        if [ "$SC" != "$TARGET" ]; then
           # minimal log to avoid spam
           # echo "  Skipping $PVC ($SC != $TARGET)"
           continue
        fi
        
        echo "  Backing up PVC: $PVC"
        SNAPSHOT_NAME="${NS}-${PVC}-${DATE}"
        
        # Create snapshot
        cat <<EOF | kubectl apply -f -
    apiVersion: snapshot.storage.k8s.io/v1
    kind: VolumeSnapshot
    metadata:
      name: ${SNAPSHOT_NAME}
      namespace: ${NS}
    spec:
      volumeSnapshotClassName: csi-rbdplugin-snapclass
      source:
        persistentVolumeClaimName: ${PVC}
    EOF
        
        # Wait for snapshot to be ready
        echo "  Waiting for snapshot to be ready..."
        for i in {1..60}; do
          READY=$(kubectl get volumesnapshot "$SNAPSHOT_NAME" -n "$NS" -o jsonpath='{.status.readyToUse}' 2>/dev/null || echo "false")
          if [ "$READY" = "true" ]; then
            echo "  Snapshot ready!"
            break
          fi
          sleep 5
        done
        
        # Create temporary PVC from snapshot
        TEMP_PVC="${SNAPSHOT_NAME}-restore"
        STORAGE_CLASS=$(kubectl get pvc "$PVC" -n "$NS" -o jsonpath='{.spec.storageClassName}')
        SIZE=$(kubectl get pvc "$PVC" -n "$NS" -o jsonpath='{.spec.resources.requests.storage}')
        
        cat <<EOF | kubectl apply -f -
    apiVersion: v1
    kind: PersistentVolumeClaim
    metadata:
      name: ${TEMP_PVC}
      namespace: backup
    spec:
      storageClassName: ${STORAGE_CLASS}
      dataSource:
        name: ${SNAPSHOT_NAME}
        kind: VolumeSnapshot
        apiGroup: snapshot.storage.k8s.io
      accessModes:
        - ReadWriteOnce
      resources:
        requests:
          storage: ${SIZE}
    EOF
        
        # Wait for PVC to be bound
        echo "  Waiting for restore PVC..."
        for i in {1..60}; do
          STATUS=$(kubectl get pvc "$TEMP_PVC" -n backup -o jsonpath='{.status.phase}' 2>/dev/null || echo "Pending")
          if [ "$STATUS" = "Bound" ]; then
            echo "  Restore PVC bound!"
            break
          fi
          sleep 5
        done
        
        # Mount and copy (using a temporary pod would be needed here)
        # For simplicity, we'll just record the snapshot info
        echo "${SNAPSHOT_NAME}" >> "${BACKUP_DIR}/snapshots.txt"
        
        # Cleanup temporary PVC (keep snapshots for recovery)
        kubectl delete pvc "$TEMP_PVC" -n backup --ignore-not-found=true
        
        echo "  Snapshot ${SNAPSHOT_NAME} created and logged"
      done
    done

    # Cleanup old backups and snapshots
    echo "Cleaning up backups older than ${RETENTION_DAYS} days..."
    find "${BACKUP_ROOT}" -type d -mtime +${RETENTION_DAYS} -exec rm -rf {} + 2>/dev/null || true

    # Cleanup old snapshots
    for NS in $NAMESPACES; do
      OLD_SNAPSHOTS=$(kubectl get volumesnapshots -n "$NS" -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo "")
      for SNAP in $OLD_SNAPSHOTS; do
        CREATED=$(kubectl get volumesnapshot "$SNAP" -n "$NS" -o jsonpath='{.metadata.creationTimestamp}')
        CREATED_EPOCH=$(date -d "$CREATED" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$CREATED" +%s 2>/dev/null || echo "0")
        NOW_EPOCH=$(date +%s)
        AGE_DAYS=$(( (NOW_EPOCH - CREATED_EPOCH) / 86400 ))
        if [ "$AGE_DAYS" -gt "$RETENTION_DAYS" ]; then
          echo "  Deleting old snapshot: $SNAP (${AGE_DAYS} days old)"
          kubectl delete volumesnapshot "$SNAP" -n "$NS" --ignore-not-found=true
        fi
      done
    done

    echo "=== Backup Export Completed at $(date) ==="
---
# CronJob for daily backup
apiVersion: batch/v1
kind: CronJob
metadata:
  name: pvc-backup
  namespace: backup
spec:
  schedule: "0 3 * * *" # 3 AM daily
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      backoffLimit: 2
      template:
        spec:
          serviceAccountName: backup-exporter
          restartPolicy: OnFailure
          containers:
            - name: backup
              image: bitnami/kubectl:latest
              command: ["/bin/bash", "/scripts/backup.sh"]
              env:
                - name: RETENTION_DAYS
                  value: "90"
                - name: TARGET_STORAGE_CLASS
                  value: "rook-ceph-block"
              volumeMounts:
                - name: backup-storage
                  mountPath: /backup
                - name: backup-script
                  mountPath: /scripts
          volumes:
            - name: backup-storage
              persistentVolumeClaim:
                claimName: backup-storage
            - name: backup-script
              configMap:
                name: backup-script
                defaultMode: 0755
